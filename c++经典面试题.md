C++经典面试题
1，关于动态申请内存
答：内存分配方式三种：
（1）从静态存储区域分配：内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。
全局变量，static变量。
（2）在栈上创建：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，
函数执行结束时这些存储单元自动被释放。
栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
（3）用malloc或new申请内存之后，应该立即检查指针值是否为NULL.防止使用指针值为NULL的内存，
不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。避免数组或指针的下标越界，
特别要当心发生“多1”或者“少1”操作。动态内存的申请与释放必须配对，防止内存泄漏。
用free或delete释放了内存之后，立即将指针设置为NULL，防止产生“野指针”。从堆上分配，亦称动态内存分配。
程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。
动态内存的生存期由程序员决定，使用非常灵活。（int *pArray;   int MyArray[6];    pArray = &MyArray[0];）
如果在申请动态内存时找不到足够大的内存块，malloc和new将返回NULL指针，
判断指针是否为NULL，如果是则马上用return语句终止本函数，
或者马上用exit(1)终止整个程序的运行，为new和malloc设置异常处理函数。
 
2，C++指针攻破
答案：指针是一个变量，专门存放内存地址，特点是能访问所指向的内存
 
指针本身占据了4个字节的长度
int **ptr; //指针的类型是 int **
int (*ptr)[3]; //指针的类型是 int(*)[3] 
int *(*ptr)[4]; //指针的类型是 int *(*)[4] 
 ptr++：指针ptr的值加上了sizeof(int)
ptr+=5：将指针ptr的值加上5*sizeof(int)
 
指针的赋值:
把一个变量的地址赋予指向相同数据类型的指针变量( int a;   int *ip;   ip=&a; )
把一个指针变量的值赋予指向相同类型变量的另一个指针变量(int a;  int *pa=&a;  int *pb;   pb=pa; )
把数组的首地址赋予指向数组的指针变量(int a[5],*pa;  pa=a;   也可写为：pa=&a[0];)
 
如果给指针加1或减1 ，实际上是加上或减去指针所指向的数据类型大小。
当给指针加上一个整数值或减去一个整数值时，表达式返回一个新地址。
相同类型的两个指针可以相减，减后返回的整数代表两个地址间该类型的实例个数。
 
int ** cc=new (int*)[10]; 声明一个１０个元素的数组，数组每个元素都是一个int *指针，
每个元素还可以单独申请空间，因为cc的类型是int*型的指针，所以你要在堆里申请的话就要用int *来申请；
   int ** a= new int * [2];　　　　　//申请两个int * 型的空间
   a[0] = new int[4];　　　　　　　　////为a的第一个元素申请了４个int 型空间，a[0] 指向了此空间的首地址处
   a[1] = new int[3];　　　　　　　　//为a的第二个元素又申请了３个int 型空间,a[1]指向了此空间首地址处
 
指针数组初始化赋值：
一维指针开辟空间：char *str；int *arr;    scanf("%d",&N);
str=(char*)malloc(sizeof(char)*N);
arr=(int*)malloc(sizeof(int)*N);
二维指针开辟空间：int **arr,      i;          scanf("%d%d",&row,&col);
arr=(int**)malloc(sizeof(int)*row);
for(i=0;i<row;i++)
   arr[i]=(int*)malloc(sizeof(int)*col);
 
结构体指针数组，例如typedef struct{   char x;   int  y; }Quan,*QQuan;
定义一个结构体指针数组如：QQuan a[MAX] 
for(i=0;i<MAX;i++)
{
    a[i]=(QQuan)malloc(sizeof(Quan));
    memset(a[i],0,sizeof(Quan));
}
指针数组赋值
 float a[]={100,200,300,400,500};
float  *p[5]={&a[0],&a[1],&a[2],&a[3],&a[4]};
 
 
char *units[1000];
char get_unit[250];                                                                           
for(int i=0;i<get_unit_num;i++){ units[i]=(char*) malloc(60*sizeof(char*)); 
scanf("%s", get_unit);   strcpy(units[i],get_unit);}
 
 
3,复杂指针解析：
（1）int (*func)(int *p);
（*func）（）是一个函数，func是一个指向这类函数的指针，就是一个函数指针，这类函数具有int*类型的形参，返回值类型是 int。
（2）int (*func)(int *p, int (*f)(int*));
func是一个指向函数的指针，这类函数具有int *和int (*)(int*)这样的形参。形参int (*f)(int*），f也是一个函数指针
(3)int (*func[5])(int *p);
func数组的元素是函数类型的指针，它所指向的函数具有int*类型的形参，返回值类型为int。
(4)int (*(*func)[5])(int *p);
func是一个指向数组的指针，这个数组的元素是函数指针，这些指针指向具有int*形参，返回值为int类型的函数。
(5)int (*(*func)(int *p))[5];
func是一个函数指针，这类函数具有int*类型的形参，返回值是指向数组的指针，所指向的数组的元素是具有5个int元素的数组。
注意：
需要声明一个复杂指针时，如果把整个声明写成上面所示的形式，对程序可读性是一大损害。
应该用typedef来对声明逐层,分解，增强可读性，例如对于声明：int (*(*func)(int *p))[5];
这样分解：typedef  int (*PARA)[5];    typedef PARA (*func)(int *);
 
例如：int (*(*func)[5][6])[7][8];
　　func是一个指向数组的指针，这类数组的元素是一个具有5X6个int元素的二维数组，而这个二维数组的元素又是一个二维数组。
　　typedef int (*PARA)[7][8];
　　typedef PARA (*func)[5][6];
例如：int (*(*(*func)(int *))[5])(int *);
　　func是一个函数指针，这类函数的返回值是一个指向数组的指针，
所指向数组的元素也是函数指针，指向的函数具有int*形参，返回值为int。
　　typedef int (*PARA1)(int*);
　　typedef PARA1 (*PARA2)[5];
　　typedef PARA2 (*func)(int*);
 
 
4，函数指针详解
答：
函数指针是指向一个函数入口的指针
一个函数指针只能指向一种类型的函数，即具有相同的返回值和相同的参数的函数。
函数指针数组定义：void(*fun[3])(void*);  相应指向类A的成员函数的指针：void (A::*pmf)(char *, const char *);
指向外部函数的指针：void (*pf)(char *, const char *); void strcpy(char * dest, const char * source)； pf=strcpy;
 
 
5，野指针
答：“野指针”是很危险的，if语句对它不起作用。“野指针”的成因主要有两种：
（1）指针变量没有被初始化。指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。
char *p = NULL;      char *str = (char *) malloc(100);
（2）指针p被free或者delete之后，没有置为NULL
（3）指针操作超越了变量的作用范围。所指向的内存值对象生命期已经被销毁
 
6,引用和指针有什么区别？
答：引用必须初始化，指针则不必；引用初始化以后不能改变，指针可以改变其指向的对象；
不存在指向空值的引用，但存在指向控制的指针；
引用是某个对象的别名，主要用来描述函数和参数和返回值。而指针与一般的变量是一样的，会在内存中开辟一块内存。
如果函数的参数或返回值是类的对象的话，采用引用可以提高程序的效率。
 
7，C++中的Const用法
答：char * const p;    // 指针不可改,也就说指针只能指向一个地址,不能更改为其他地址，修饰指针本身
char const * p;   // 所指内容不可改,也就是说*p是常量字符串，修饰指针所指向的变量
const char * const p 和 char const * const p; // 内容和指针都不能改
 
const修饰函数参数是它最广泛的一种用途，它表示函数体中不能修改参数的值，
传递过来的参数在函数内不可以改变，参数指针所指内容为常量不可变，参数指针本身为常量不可变
在引用或者指针参数的时候使用const限制是有意义的,而对于值传递的参数使用const则没有意义
 
const修饰类对象表示该对象为常量对象，其中的任何成员都不能被修改。
const修饰的对象，该对象的任何非const成员函数都不能被调用，因为任何非const成员函数会有修改成员变量的企图。
const修饰类的成员变量,表示成员常量，不能被修改，同时它只能在初始化列表中赋值。static const 的成员需在声明的地方直接初始。
const修饰类的成员函数，则该成员函数不能修改类中任何非const成员。一般写在函数的最后来修饰。
在函数实现部分也要带const关键字.
对于const类对象/指针/引用，只能调用类的const成员函数，因此，const修饰成员函数的最重要作用就是限制对于const对象的使用
 
使用const的一些建议：在参数中使用const应该使用引用或指针，而不是一般的对象实例
const在成员函数中的三种用法（参数、返回值、函数）要很好的使用；
const在成员函数中的三种用法（参数、返回值、函数）要很好的使用；
不要轻易的将函数的返回值类型定为const;除了重载操作符外一般不要将返回值类型定为对某个对象的const引用;
 
8，const常量与define宏定义的区别
答：(1) 编译器处理方式不同。define宏是在预处理阶段展开，生命周期止于编译期。
只是一个常数、一个命令中的参数，没有实际的存在。
#define常量存在于程序的代码段。const常量是编译运行阶段使用，const常量存在于程序的数据段.
 
（2）类型和安全检查不同。define宏没有类型，不做任何类型检查，仅仅是展开。
const常量有具体的类型，在编译阶段会执行类型检查。
（3） 存储方式不同。define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。
const常量会在内存中分配(可以是堆中也可以是栈中)
 
9，解释堆和栈的区别
答：1、栈区（stack）— 由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。
由系统自动分配。声明在函数中一个局部变量 int b; 系统自动在栈中为b开辟空间 。
只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。
在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域，栈的大小是2M。
如果申请的空间超过栈的剩余空间时，将提示overflow。
栈由系统自动分配，速度较快。但程序员是无法控制的。
函数调用时，第一个进栈的是主函数中后的下一条指令，的地址，然后是函数的各个参数。
在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。
 
堆区（heap） — 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收 。
注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，需要程序员自己申请，并指明大小，在c中malloc函数
在C++中用new运算符。首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，
另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。
堆是向高地址扩展的数据结构，是不连续的内存区域。而链表的遍历方向是由低地址向高地址。
堆的大小受限于计算机系统中有效的虚拟内存。
堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便
一般是在堆的头部用一个字节存放堆的大小。
 
10，论述含参数的宏和函数的优缺点
（1）函数调用时，先求出实参表达式的值，然后代入形参。而使用带参的宏只是进行简单的字符替换
（2）函数调用是在程序运行时处理的，分配临时的内存单元；而宏展开是在编译时进行的，在展开时不进行
内存分配，不进行值得传递处理，没有“返回值”概念
（3）对函数中的形参和实参都要定义类型，类型要求一致，如不一致则进行类型转换。而宏不存在类型问题
（4）调用函数只可得到一个返回值，而用宏则可以设法得到几个结果
（5）实用宏次数多时，宏展开后源程序变长，没展开一次源程序增长，函数调用则不会
（6）宏替换不占用运行时间，只占编译时间，而函数调用占用运行时间
 
11，C++的空类，默认产生哪些类成员函数？
答：class Empty
{
 public:
Empty();                           //缺省构造函数
Empty（const Empty& ）;           //拷贝构造函数
~Empty();                          //虚构函数
Empty& operator(const Empty& )     //赋值运算符
Empty& operator&();               //取址运算符
const Empty* operator&() const;   // 取址运算符 const
}
 
12，谈谈类和结构体的区别
答：结构体在默认情况下的成员都是public的,而类在默认情况下的成员是private的。结构体和类都必须使用new创建，
struct保证成员按照声明顺序在内存在存储，而类不保证。
 
13，C++四种强制类型转换
答：（1）const_cast
字面上理解就是去const属性，去掉类型的const或volatile属性。
struct SA{  int k};  const SA ra;   
ra.k = 10;    //直接修改const类型，编译错误   SA& rb =  const_cast<SA&>(ra);   rb.k = 10; //可以修改
 
（2）static_cast
主要用于基本类型之间和具有继承关系的类型之间的转换。用于指针类型的转换没有太大的意义
static_cast是无条件和静态类型转换，可用于基类和子类的转换，基本类型转换，把空指针转换为目标类型的空指针，
把任何类型的表达式转换成void类型，static_cast不能进行无关类型(如非基类和子类)指针之间的转换。
int a;     double d = static_cast<double>(a);   //基本类型转换
int &pn = &a;     void *p = static_cast<void*>(pn);   //任意类型转换为void
 
(3)dynamic_cast
 
你可以用它把一个指向基类的指针或引用对象转换成继承类的对象
动态类型转换，运行时类型安全检查(转换失败返回NULL)
基类必须有虚函数，保持多态特性才能用dynamic_cast
只能在继承类对象的指针之间或引用之间进行类型转换
class BaseClass{public:  int m_iNum;  virtual void foo(){};};
class DerivedClass:BaseClass{public: char* szName[100];  void bar(){};};
BaseClass* pb = new DerivedClass();
 
DerivedClass *p2 = dynamic_cast<DerivedClass *>(pb);
BaseClass* pParent = dynamic_cast<BaseClass*>(p2);
//子类->父类，动态类型转换，正确
 
(4)reinterpreter_cast
转换的类型必须是一个指针、引用、算术类型、函数指针或者成员指针。
主要是将一个类型的指针，转换为另一个类型的指针
不同类型的指针类型转换用reinterpreter_cast
最普通的用途就是在函数指针类型之间进行转换
int DoSomething(){return 0;};
typedef void(*FuncPtr)(){};
FuncPtr funcPtrArray[10];
funcPtrArray[0] = reinterpreter_cast<FuncPtr>(&DoSomething);
 
14,C++函数中值的传递方式有哪几种?
答：函数的三种传递方式为：值传递、指针传递和引用传递。
 
15，将“引用”作为函数参数有哪些特点
答：（1）传递引用给函数与传递指针的效果是一样的，这时，被调函数的形参就成为原来主调函数的实参变量或者
对象的一个别名来使用，所以在被调函数中形参的操作就是对相应的目标对象的操作
（2）使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作，当参数数据较大时，引用
传递参数的效率和所占空间都好
（3）如果使用指针要分配内存单元，需要重复使用“*指针变量名”形式进行计算，容易出错且阅读性较差。
 
16，简单叙述面向对象的三个基本特征
答：封装性
把客观事物封装成抽象的类，对自身的数据和方法进行（public，private， protected）
继承性
继承概念的实现方式有三类：实现继承、接口继承和可视继承。
实现继承是指使用基类的属性和方法而无需额外编码的能力；
接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力；
可视继承是指子窗体（类）使用基窗体（类）的外观和实现代码的能力。
抽象类仅定义将由子类创建的一般属性和方法，创建抽象类时，请使用关键字 Interface 而不是 Class
多态性
多态性（polymorphisn）是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，
父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。允许将子类类型的指针赋值给父类类型的指针。
实现多态，有二种方式，覆盖（子类重新定义父类的虚函数），重载（允许存在多个同名函数，参数个数，类型不同）。
 
17，类成员函数的overload， override 和 隐藏的区别
答： （1）成员函数被重载的特征：相同的类范围，函数名字相同，参数不同，virtual 关键字可有可无。
（2）覆盖指派生类的函数覆盖基类函数，特征是分别位于基类和派生类，函数名字相同，参数相同，基类函数必须有virtual关键字
（3）隐藏是指派生类的函数屏蔽了与其同名的基类函数。1，派生类的函数与基类的函数同名，但是参数不同，
不论有无virtual关键字，基类的函数将被隐藏 2，派生类的函数与基类的函数同名，并且参数也相同，
但是基类函数没有virtual 关键字。此时，基类的函数被隐藏
3种情况怎么执行：重载：看参数；隐藏：用什么就调用什么；覆盖：调用派生类 。
 
18，什么是预编译，何时需要预编译
答：就是指程序执行前的一些预处理工作,主要指#表示的.
需要预编译的情况:总是使用不经常改动的大型代码体。所有模块都使用一组标准的包含文件和相同的编译选项。
 
19,memset ,memcpy 和strcpy 的根本区别？
答：memset用来对一段内存空间全部设置为某个字符，一般用在对定义的字符串进行初始化为' '或''；
它对较大的结构体或数组进行清零操作的一种最快方法。
char temp[30];     memset(temp,'\0',sizeof(temp));
char temp[30]只是分配了一定的内存空间给该字符数组，但并未初始化该内存空间，即数组。所以，需要使用memset()来进行初始化。
memcpy用来做内存拷贝，你可以拿它拷贝任何数据类型的对象，可以指定拷贝的数据长度；
strcpy就只能拷贝字符串了，它遇到'\0'就结束拷贝；例：char a[100],b[50];strcpy(a,b);
 
20，多态类中的虚函数表是Compile-Time，还是Run-Time时建立的?
答：虚拟函数表是在编译期就建立了,各个虚拟函数这时被组织成了一个虚拟函数的入口地址的数组.
而对象的隐藏成员--虚拟函数表指针是在运行期也就是构造函数被调用时进行初始化的,这是实现多态的关键.
 
21，Template有什么特点？什么时候用？
答： Template可以独立于任何特定的类型编写代码,是泛型编程的基础.
当我们编写的类和函数能够多态的用于跨越编译时不相关的类型时,用Template.
模板主要用于STL中的容器,算法,迭代器等以及模板元编程.
C++的template是实现在库设计和嵌入式设计中的关键，
能实现抽象和效率的结合；同时template还能有效地防止代码膨胀
C++中为什么用模板类？
1)可用来创建动态增长和减小的数据结构
2）它是类型无关的，因此具有很高的可复用性
3）它在编译时而不是运行时检查数据类型，保证了类型安全
4）它是平台无关的，可移植性
5）可用于基本数据类型
 
22，进程和线程的差别？
答：线程是指进程内的一个执行单元,也是进程内的可调度实体.区别：
(1)调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位
(2)并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行
(3)拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源.
(4)系统开销：创建撤消进程，系统都要为之分配和回收资源，系统的开销明显大于创建撤消线程
多进程与多线程，两者都可以提高程序的并发度，提高程序运行效率和响应时间。
 
23，请说出static关键字尽可能多的作用
答：（1)函数体内作用范围为该函数体，该变量内存只被分配一次，具有记忆能力
（2）在模块内的static全局变量可以被模块内所有函数访问，但不能被模块外其它函数访问；
（3）在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；
（4）在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；
（5）在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。
 
24，头文件的作用是什么?
答：一，通过头文件来调用库功能。在很多场合，源代码不便（或不准）向用户公布，只要向用户提供头文件
和二进制的库即可。用户只需要按照头文件中的接口声明来调用库功能，而不必关心接口怎么实现的。
编译器会从库中提取相应的代码。
二,头文件能加强类型安全检查。如果某个接口被实现或被使用时，其方式与头文件中的声明不一致，
编译器就会指出错误，这一简单的规则能大大减轻程序员调试、改错的负担。
 
25,在C++程序中调用C编译后的函数，为什么要加extern C的声明？
答：因为C++支持函数重载，而C不支持函数重载，函数被C++编译后在库中的名字与C语言的不同。
假设某个函数的原型为：void foo(int x, int y)；该函数被C编译器编译后在库中的名字为_foo，
而C++编译器则产生像_foo_int_int之类的名字。 C++提供extern C来解决名字匹配问题
 
26，C++中哪些函数不能被声明为虚函数？
答：普通函数（非成员函数），构造函数，内联成员函数、静态成员函数、友元函数。
（1）虚函数用于基类和派生类，普通函数所以不能
（2）构造函数不能是因为虚函数采用的是虚调用的方法，允许在只知道部分信息的情况的工作机制，
特别允许调用只知道接口而不知道对象的准确类型的方法，但是调用构造函数即使要创建一个对象，
那势必要知道对象的准确类型。
（3）内联成员函数的实质是在调用的地方直接将代码扩展开
（4）继承时，静态成员函数是不能被继承的，它只属于一个类，因为也不存在动态联编等
（5）友元函数不是类的成员函数，因此也不能被继承
 
27, 数组int c[3][3]; 为什么c，*c的值相等，（c+1），（*c+1）的值不等, c，*c，**c，代表什么意思？
答：c是第一个元素的地址，*c是第一行元素的首地址，其实第一行元素的地址就是第一个元素的地址，
**c是提领第一个元素。 为什么c，*c的值相等？
c： 数组名；是一个二维指针，它的值就是数组的首地址，也即第一行元素的首地址（等于 *c），
也等于第一行第一个元素的地址（ & c[0][0]）；可以说成是二维数组的行指针。
*c： 第一行元素的首地址；是一个一维指针，可以说成是二维数组的列指针。
**c：二维数组中的第一个元素的值；即：c[0][0]
所以：c 和 *c的值是相等的，但他们两者不能相互赋值，（类型不同）
（c + 1） ：c是行指针，（c + 1）是在c的基础上加上二维数组一行的地址长度，
即从&c[0][0]变到了&c[1][0]；
（*c + 1）：*c是列指针，（*c + 1）是在*c的基础上加上二数组一个元素的所占的长度，
&c[0][0]变到了&c[0][1]，从而（c + 1）和（*c + 1）的值就不相等了。
 
28，定义  int **pa[4][3],则变量pa占有的内存空间是多少？
答：int **p,在32位机器上 sizeof（p） = 4;
总共占有4*3*sizeof（p） = 48.
 
29,拷贝构造函数相关问题，深拷贝，浅拷贝，临时对象等
答：在C++中，三种对象需要拷贝的情况：一个对象以值传递的方式传入函数体，
 一个对象以值传递的方式从函数返回，一个对象需要通过另外一个对象进行初始化。
执行先父类后子类的构造，对类中每一个数据成员递归地执行成员拷的动作.
深拷贝：如果一个类拥有资源，深拷贝意味着拷贝了资源和指针
浅拷贝：如果对象存在资源，而浅拷贝只是拷贝了指针，没有拷贝资源，
这样使得两个指针指向同一份资源，造成对同一份析构两次，程序崩溃。
临时对象的开销比局部对象小些。
 
临时对象：辅助一个表达式的计算 a + b + c ，或者间接构造的实参，函数返回非引用的时候，
都可能产生临时对象，临时对象生命周期，是单个语句，是右值。
临时对象的开销比局部对象小些。
 
30，指针和引用有什么分别；
答：引用必须初始化，即引用到一个有效的对象；而指针在定义的时候不必初始化，
可以在定义后面的任何地方重新赋值。
引用初始化后不能改变，指针可以改变所指的对象
不存在指向NULL的引用，但存在指向NULL的指针
引用的创建和销毁并不会调用类的拷贝构造函数
语言层面，引用的用法和对象一样；在二进制层面，引用一般都是通过指针来实现的，
只不过编译器帮我们完成了转换.引用既具有指针的效率，又具有变量使用的方便性和直观性．
 
31,写一个"标准"宏MIN,这个宏输入两个参数并返回较小的一个
答：面试者注意谨慎将宏定义中的“参数”和整个宏用括号括起来
#define      MIN(A, B)     ((A) <= (B)? (A):(B))
 
32,用一个宏定义FIND求一个结构体struc中某个变量相对struc的偏移量
答：  #define FIND(struc, e)  (size_t)&( ((struc*)0)->e )
解析：其中（struc*）0表示将常量0转化为struc*类型指针所指向的地址。
&( ((struc*)0)->e )表示取结构体指针（struc*）0的成员e的地址，因为该结构体的首地址为0，
所以其实就是得到了成员e距离结构体首地址的偏移量，（size_t）是一种数据类型，为了便于不同系统之间的移植，
最好定义为一种无符号型数据，一般为unsigned int
 
33,解析sizeof 以及 结构体的对齐问题
答：（1）sizeof（type），用于数据类型；
sizeof（var_name）或sizeof　var_name用于变量　
sizeof操作符不能用于函数类型，不完全类型或位字段。
不完全类型指具有未知存储大小的数据类型，如未知存储大小的数组类型、未知内容的结构或联合类型、void类型等。
如int　max(),  char　char_v　[MAX]且MAX未知  ， void类型
那么sizeof(max)，sizeof(char_v)，sizeof(void)都是错误的
 
当sizeof的参数为数组或者指针时
int   a[50];     //sizeof(a)=4*50=200;   求数组所占的空间大小
int   *a=new   int[50];//   sizeof(a)=4;   a为一个指针，sizeof(a)是求指针  
当sizeof的参数为结构或类时候
结构或者类中的静态成员不对结构或者类的大小产生影响，因为静态变量的存储位置 。
与结构或者类的实例地址无关。没有成员变量的结构或类的大小为1，
因为必须保证结构或类的每一 实例在内存中都有唯一的地址
 
（2）class MyStruct{   double ddal;    char dda;    int type;}
在VC中测试上面结构的大小时，你会发现sizeof(MyStruct)为16。
其实，这是VC对变量存储的一个特殊处理。为了提高CPU的存储速度，VC对一些变量的起始
地址做了“对齐”处理。在默认情况下，VC规定各成员变量存放的起始地址相对于结构的
始地址偏移量必须为该变量的类型占用字节数的倍数,如Char偏移量为sizeof(char)即1的倍数
 
先为第一个成员dda1分配空间，其起始地址跟结构的起始地址相同，偏移量0刚好为sizeof(double)的倍数，
该成员变量占用sizeof(double)=8个字节；接下来为第二个成员dda分配空间，这时
下一个可以分配的地址对于结构的起始地址的偏移量为8，是sizeof(char)的倍数，占sizeof(char)=1字节
为第三个成员type分配空间，这时下一个可以分配的地址对于结构的起始地址的偏移量为9
，不是sizeof(int)=4的倍数，为了满足对齐方式对偏移量的约束问题，VC自动填充3个字节
这时下一个可以分配的地址对于结构的起始地址的偏移量是12，刚好是sizeof(int)=4的倍数，
所以把type存放在偏移量为12的地方，占 用sizeof(int)=4个字节。总的占用的空间大
小为：8+1+3+4=16，刚好为结构的字节边界数（即结构中占用最大空间的类型所占用的字节
数sizeof(double)=8）的倍数，所以没有空缺的字节需要填充。
 
34,在main函数执行之前，还会执行什么代码和工作
答：运行全局构造器，全局对象的构造函数会在main函数之前执行
设置栈指针，初始化static静态和global全局变量，即数据段的内容
将未初始化部分的赋初值：数值型short，int，long等为0，bool为FALSE，指针为NULL等
将main函数的参数，argc，argv等传递给main函数
 
35，如何判断一段程序是由C 编译程序还是由C++ 编译程序编译的？
答：C++ 编译时定义了 __cplusplus
C 编译时定义了 _STDC_
 
36，分别写出BOOL，int， float, 指针类型的变量 a 与 “零值”的比较语句
答：
  BOOL: if（!a）   or   if(a)
    int : if( 0 == a)
  float : const EXPRESSION EXP = 0.000001;
  if(a < EXP && a > -EXP)
 pointer:     if(a != NULL) or  if(a == NULL)
 
37,已知String类定义如下,尝试写出类的成员函数实现
class{
public:
String(const char*str = NULL);             //通用构造函数
String(const String& another);             //拷贝构造函数
~String();                                 //析构函数
String& operator = = (const String& rhs);  //赋值函数
private:
char* m_data;                              //用于保存字符串
};
 
答：
String::String（const char*str）
{
     if(str == NULL)
     {
            m_data = new char[1];
            m_data[0] = '\0';
     }
     else
     {
            m_data = new char[strlen(str)+1];
            strcpy(m_data, str);        
     }
}   
String::String(const String& another)
{
     m_data = new char[strlen(another.m_data)+1];
     strcpy(m_data, another.m_data); 
}                          
String::String& operator = = (const String& rhs)
{
    if(this == &rhs)
    return &this;
    delete[]  m_data;
    m_data = new char(strlen(rhs.m_data)+1);   //删除原来的数据，新开一块内存
   strcpy(m_data, rhs.m_data); 
     return *this;
}
~String()
{
    delete[]  m_data;
}
 
38,论述C++类继承的优缺点
答：一，优点：类继承是在编译时刻静态定义的，可以直接使用，类继承可以较方便的改变从父类继承的实现
二，缺点：1，因为继承在编译时刻就定义了，所以无法在运行时刻改变从父类继承的实现
2，父类通常至少定义了子类的部分行为，父类的任何改变都可能影响到子类的行为
3，如果继承下来的实现不适合解决新的问题，则父类必须重写或被其他更适合的类替换
这种依赖关系先限制了灵活性并最终限制了复用性
 
39，运算符重载的三种方式和不允许重载的5个运算符
答：运算符重载意义是为了对用户自定义数据的操作和内定义的数据类型的操作形式一致
(1)普通函数，友元函数，类成员函数
（2）.*（成员指针访问运算符）   
      ：：（域运算符） 
      sizeof 长度运算符   
    ？：条件运算符   
     .(成员访问运算符)
40，友元关系有什么特性？
答：单向的，非传递的， 不能继承的.
 
41,理解析构函数和虚函数的用法和作用？
答：析构函数也是特殊的类成员函数，它没有返回类型，没有参数，不能随意调用，也没有重载。
在类对象生命期结束的时候，由系统自动调用释放在构造函数中分配的资源。
析构函数一般在对象撤消前做收尾工作，比如回收内存等工作。
 
虚函数的功能是使子类可以用同名的函数对父类函数进行重载，并且在调用时自动调用子类重载函
数，在基类中通过使用关键字virtual来声明一个函数为虚函数，该函数的功能可能在将来的派生类
中定义或者在基类的基础上扩展，系统只能在运行阶段才能动态的决定调用哪一个函数，动态的多态性，
如果是纯虚函数，则纯粹是为了在子类重载时有个统一的命名而已。
 
42,关键字volatile有什么含意?并给出三个不同的例子
答：一个定义为volatile的变量是说这变量可能会被意想不到地改变，编译器就不会去假设这个变量的值了。
精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值
而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子：
1) 并行设备的硬件寄存器（如：状态寄存器）
2) 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)
3) 多线程应用中被几个任务共享的变量
 
深究：一个参数既可以是const还可以是volatile，一个例子是只读的状态寄存器，
它是volatile因为它可能被意想不到地改变，是const因为程序不应该试图去修改它。
一个指针可以是volatile，一个例子是当一个中服务子程序修该一个指向一个buffer的指针时。
 
43，动态连接库的两种方式?
答：调用一个DLL中的函数有两种方法：
1．载入时动态链接（load-time dynamic linking），模块非常明确调用某个导出函数
，使得他们就像本地函数一样。这需要链接时链接那些函数所在DLL的导入库，导入库向
系统提供了载入DLL时所需的信息及DLL函数定位。
2．运行时动态链接（run-time dynamic linking），运行时可以通过LoadLibrary或Loa
dLibraryEx函数载入DLL。DLL载入后，模块可以通过调用GetProcAddress获取DLL函数的
出口地址，然后就可以通过返回的函数指针调用DLL函数了。如此即可避免导入库文件了。
 
44，C和C++有什么不同?
答：从机制上：c是面向过程的。c++是面向对象的，提供了类。c++编写面向对象的程序比c容易。
从适用的方向：c适合要求代码体积小的，效率高的场合，如嵌入式；c++适合更上层的，复杂的； 
llinux核心大部分是c写的，因为它是系统软件，效率要求极高。
C语言是结构化编程语言，C++是面向对象编程语言
C++侧重于对象而不是过程，侧重于类的设计而不是逻辑的设计。
 
45，C++编译器自动为类产生的四个确缺省函数是什么？
答：默认构造函数，拷贝构造函数，析构函数，赋值函数
 
46，简单描述Windows内存管理的方法。
答：程序运行时需要从内存中读出这段程序的代码，代码的位置必须在物理内存中才能被运行，
由于现在的操作系统中有非常多的程序运行着，内存中不能够完全放下，所以引出了虚拟内存的概念。
把哪些不常用的程序片断就放入虚拟内存，当需要用到它的时候在load入主存（物理内存）中。
内存管理也计算程序片段在主存中的物理位置，以便CPU调度。
 
内存管理有块式管理，页式管理，段式和段页式管理。现在常用段页式管理
块式管理：把主存分为一大块、一大块的，当所需的程序片断不在主存时就分配一块主存空间，
把程 序片断load入主存，就算所需的程序片度只有几个字节也只能把这一块分配给它。
这样会造成很大的浪费，平均浪费了50％的内存空间，但时易于管理。
页式管理：把主存分为一页一页的，每一页的空间要比一块一块的空间小很多，显然这种方法
的空间利用率要比块式管理高很多
段式管理：把主存分为一段一段的，每一段的空间又要比一页一页的空间小很多，
这种方法在空间利用率上又比页式管理高很多，但是也有另外一个缺点。一个程序片断可能会被分为几十段，
这样很多时间就会被浪费在计算每一段的物理地址上，计算机最耗时间的大家都知道是I/O吧
段页式管理：结合了段式管理和页式管理的优点。把主存分为若干页，每一页又分为若干段，好处就很明显
 
47，Linux有内核级线程吗？
答：线程通常被定义为一个进程中代码的不同执行路线。从实现方式上划分，线程有两种类型：
“用户级线程”和“内核级线程”。 用户线程指不需要内核支持而在用户程序中实现的线程，其不依赖于操作系统核心，
应用进程利用线程库提供创建、同步、调度，和管理线程的函数来控制用户线程。内核级线程需要内核的参与，
由内核完成线程的调度。其依赖于操作系统核心，由内核的内部需求进行创建和撤销。
 
用户线程不需要额外的内核开支，并且用户态线程的实现方式可以被定制或修改以适应特殊应用的要求，
但是当一个线程因 I/O 而处于等待状态时，整个进程就会被调度程序切换为等待状态，其他线程得不
到运行的机会；而内核线程则没有这个个限制，有利于发挥多处理器的并发优势，但却占用了更多的系统开支。
 
48，main 主函数执行完毕后，是否可能会再执行一段代码，给出说明？
答：可以，可以用_onexit 注册一个函数，它会在main 之后执行int fn1(void), fn2(void), fn3(void), fn4 (void)
 
49， i++ 相比 ++i 哪个更高效？为什么？
答：
（1)＋＋i 比 i++效率高。
(2)i＋＋要多调用一次类的构造和析够函数
 
50，windows平台下网络编程有哪几种网络编程模型？
答：有阻塞，select，基于窗体的事件模型，事件模型，重叠模型，完成端口模型。
除了阻塞模型外，其他都是非阻塞模型，其中效率最高的是完成端口模型，尤其在windows下服务器最合适了。
做客户端一般用事件模型了,select在window和类unix都可以使用。
 
51,什么是函数模板
答：函数模板技术定义了参数化的非成员函数，使得程序能够使用不同的参数类型调用相同的函数，而至于是何种类型，
则是由编译器确定从模板中生成相应类型的代码。编译器确定了模板函数的实际类型参数，称之为模板的实例化。
template<class T>定义模板标识
T Add(T a, T b)         //函数模板
{
   T result = a + b;
   return a + b;    //将两个参数使用“+”运算符进行运算，这两个参数并不知道是何种类型
}
该函数与一般函数的不同之处在于没有明确指出使用何种数据类型和返回值又是哪一种类型
如何在程序中调用该函数
#include<iostream>  //包含标准输入输出头文件
#include<string>   //C++中的字符串处理头文件
using namespace std;
template<class T>
T Add(T a, T b)         //函数模板
{
   T result = a + b;
   return a + b;    //将两个参数使用“+”运算符进行运算，这两个参数并不知道是何种类型
}
int main(int argc, char* argv[])
{
    cout<<"2+3="<<Add(2,3)<<endl;  //输出整形的+运算结果
   cout<<"sdf+123="<<Add(string("sdf"), string("123"))<<endl;
  return 0;
}
 
52,什么是类模板
答：描述了能够管理其他数据类型的通用数据类型，通常用于建立包含其他类型的容器类
对于这些容器，无论是哪一种数据类型，其操作方式是一样的，但是针对具体的类型又是专用的，
template<class T>
class TemplateSample
{
   private:
    T& emtity;            //使用参数类型成员
    public:
  void F(T& arg);        //使用参数类型定义成员函数
}
该示例定义了一个类模板，类模板中的模板形参T需要用户在使用的时候进行定义
TemplateSample<int>demo;   //针对该模板使用int类型
demo.F(123);   //调用类模板中的成员函数
template<class T1, class T2, int num>      //定义多个模板参数，且其中一个直接使用int类型
该示例的前两个参数可以是任何类型，但是第三个参数一定是int类型
TemplateSample<int , char, 12>demo;      //使用非类类型的模板
#include<iostream>
template<class T, class T2, int num>
class CSampleTemplate
{
   private:
   T t1;
   T2 t2;
  public:
  CSampleTemplate(T arg1, T2 arg2)         //构造函数中使用模板参数
  {
      t1 = arg1 + num;
      t2 = arg2 + num;
  }
  void Write()
 {
  std::cout<<"t1:"<<t1<<"t2"<<t2<<endl;
 }
 
CSampleTemplate ()
{}
}
int main(int argc, char* argv[])
{
    CSampleTemplate<int, int, 3>temp(1,2);
    temp.Write();
    return 0;
}
53,什么是容器
答：STL是一个标准的C++库，容器只是其中一个重要的组成部分,有顺序容器和关联容器
1）顺序容器,指的是一组具有相同类型T的对象，以严格的线性形式组织在一起
包括vector<T>，   deque<T>,    list<T>
2)关联容器，提供一个key实现对对象的随机访问，其特点是key是有序的元素是按照预定义的键顺序插入的i
set<Key> ,集合，   支持唯一键值，提供对键本身的快速检索，例如set<long>:{学号}
set<Key>,多重集合，支持可重复键值，提供对键本身的快速检索，例如multiset<string>:{姓名}
map<Key, T>，支持唯一Key类型的键值，提供对另一个基于键的类型的快速检索，例如map<long,string>:{学号，姓名}
multimap<Key, T>, 多重映射，支持可重复Key值，提供对另外一个基于键类型T的快速检索，例如map<string, string>:{姓名，地址}
 
54,介绍关联容器
答：#include<vector>     //包含头文件
using std::vector           //使用命名限定
vector<int>vInts;
创建一个Widget类型为空的vector对象
vector<Widget>vWidgets;                    //空的vector对象
vector<Widget>vWidgets（500）;             //包含500个对象的vector
vector<Widget>vWidgets（500， Widget（0））;       //包含500个对象的vector，并且初始化为0
vector<Widget>vWidgetFromAnother(vWeigets);        //利用现有的vector创建一个拷贝
向vector中添加一个数据，默认方式是push_back,表示将数据添加到vector的尾部，并且按照需要来分配内存，如
for(int i = 0 ; i < 10; i ++)
v.push_back(Widget(i));
 
如果想获取vector v的大小，但不知道它是否为空，或者已经包含了数据，可用如下代码实现
int nSize = v.empty()? -1:static_cast<int>(v.size());
 
访问vector中的数据有两种方法 vector::at()   和  vector::operator[],其中vector::at()进行了边界检查
 
vector<int>v;                  //定义了vector对象
v.reserve(10);                     //分配空间但是没有初始化
for(int i = 0 ; i < 7; i++)
{  v. push_back(i);}
int iVal1 = v[7];                    //不进行边界检查
int iVal2 = v.at(7);           //进行边界检查
 
deque容器是一个双端队列，存放的元素不是以连续的方式存放的
list容器是一种链表的实现，储存的元素是通过使用双向链表实现的
 
55，什么是迭代器的范围
答：迭代器是STL提供的对一个容器中的对象的访问方法，定义了容器中对象的范围，迭代器就如同一个指针。
vector<int>v;     //声明vector变量
v.push_back(2);    //插入数据
v.push_back(1);
vector<int>::iterator first = v.begin();      //获取vector<int>的一个元素的迭代器
while1(first != v.end())           //使用迭代器遍历vector，一直到最后一个元素
{
   int i = *first;     //获取迭代器指向的元素的值
first++;
}
 
55,C++如何实现泛型编程
答：泛型编程实现了于特定类型的操作算法，由编译器根据泛型的调用所传递的类及模板生成该类型专用的代码。
#include<iostream>
#include<string>
using namespaces std;
template<class T>
T Add(T a, T b)
{
    T result;           // 使用参数化的类型定义变量
   result = a + b;
  return result;
}
int main(int argc, char* argv[])
{
  cout<<"2+3="<<Add(2,3)<<endl;  
  cout<<"sdf+123="<<Add(string("sdf"), string("123"));
   return 0;
}
 
56,参数传递的方式和多态参数传递的实现
答：参数传递有传值，传指针，或者是引用等三种，下面做详细的介绍
1）传值方式适合一般的数值传递，并且不改变原数据，但是要消耗内存空间
2）传递指针方式适合传递数组和指针，由于传递的是地址，所以直接操作会改变原数据
3）引用方式和指针方式比较类似，是相对比较新的一种方式，一般情况下能用传地址的就能用引用
而且使用引用更方便一些
实现多态主要是采用指针和引用，传值方式是复制数据，其类型编译器就已经决定，而多态是类型要等到执行器才能决定，
所以不适用传值方式来实现多态参数传递
 
57，C++和C定义结构体区别是什么？
答：C++中的结构和类其实具备几乎一样的功能，结构体内也是可以声明函数，C++的结构体和类默认具有不一样的访问属性
